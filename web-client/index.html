<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Teleoperation - WebRTC Control</title>
    <style>
        :root {
            --primary-color: #2196F3;
            --primary-dark: #1976D2;
            --success-color: #4CAF50;
            --warning-color: #FF9800;
            --error-color: #f44336;
            --emergency-color: #d32f2f;
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --text-muted: #888;
            --border-radius: 12px;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            --key-active: #4CAF50;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        header { text-align: center; margin-bottom: 20px; }
        h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--primary-color), #64B5F6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: var(--text-muted); font-size: 0.9rem; }
        .container { width: 100%; max-width: 600px; }
        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: var(--shadow);
        }
        .card-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Connection Status */
        .status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 12px;
        }
        .status-indicator { display: flex; align-items: center; gap: 8px; }
        .status-dot {
            width: 12px; height: 12px; border-radius: 50%;
            background: var(--error-color);
            animation: pulse 2s ease-in-out infinite;
        }
        .status-dot.connected { background: var(--success-color); animation: none; }
        .status-dot.connecting { background: var(--warning-color); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .connect-btn {
            padding: 10px 24px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .connect-btn:hover { background: var(--primary-dark); transform: translateY(-1px); }
        .connect-btn:disabled { background: #555; cursor: not-allowed; }

        /* Emergency Stop */
        .emergency-btn {
            width: 100%;
            padding: 16px 30px;
            background: linear-gradient(145deg, var(--emergency-color), #b71c1c);
            color: white;
            border: 3px solid #ff5252;
            border-radius: 12px;
            font-size: 1.3rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 4px 15px rgba(211, 47, 47, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 16px;
        }
        .emergency-btn:hover {
            background: linear-gradient(145deg, #e53935, #c62828);
            transform: translateY(-2px);
        }
        .emergency-btn:active { transform: translateY(1px); }
        .emergency-btn:disabled { background: #555; border-color: #666; cursor: not-allowed; box-shadow: none; }

        /* Visual Keyboard Display */
        .keyboard-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
        }
        .key-row {
            display: flex;
            gap: 8px;
        }
        .key-display {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            transition: all 0.1s ease;
            user-select: none;
        }
        .key-display .key-char {
            font-size: 1.4rem;
            font-weight: bold;
        }
        .key-display .key-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        .key-display.key-active {
            background: var(--key-active);
            border-color: var(--key-active);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
            transform: scale(1.05);
        }
        .key-display.key-active .key-label {
            color: white;
        }
        .key-spacer {
            width: 60px;
        }

        /* Current Command Display */
        .command-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            margin-bottom: 16px;
        }
        .command-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 4px;
        }
        .command-value {
            font-size: 1.1rem;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            color: var(--success-color);
        }
        .command-value.stopped {
            color: var(--text-muted);
        }

        /* Control Buttons (for touch/mouse) */
        .controls-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .control-row { display: flex; gap: 10px; }
        .control-btn {
            width: 70px; height: 70px;
            border: none; border-radius: 14px;
            background: linear-gradient(145deg, #1e2d50, #0f172a);
            color: var(--text-color);
            font-size: 1.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.4);
            user-select: none;
            touch-action: manipulation;
        }
        .control-btn:hover { background: linear-gradient(145deg, #253a5f, #162038); }
        .control-btn:active, .control-btn.active {
            background: var(--primary-color);
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.3), 0 0 15px rgba(33, 150, 243, 0.4);
        }
        .control-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-forward::before { content: '‚ñ≤'; }
        .btn-backward::before { content: '‚ñº'; }
        .btn-left::before { content: '‚óÑ'; }
        .btn-right::before { content: '‚ñ∫'; }

        /* Metrics Display */
        .metrics-display { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 14px; }
        .metric-item { background: rgba(0, 0, 0, 0.2); padding: 12px; border-radius: 8px; text-align: center; }
        .metric-label { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 3px; }
        .metric-value { font-size: 1.2rem; font-weight: 600; font-family: 'Courier New', monospace; }
        .metric-value.positive { color: var(--success-color); }
        .metric-value.negative { color: var(--error-color); }
        .metric-value.latency-good { color: var(--success-color); }
        .metric-value.latency-medium { color: var(--warning-color); }
        .metric-value.latency-bad { color: var(--error-color); }
        .metric-unit { font-size: 0.7rem; color: var(--text-muted); }

        /* Settings */
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .setting-item { display: flex; flex-direction: column; gap: 4px; }
        .setting-item label { font-size: 0.8rem; color: var(--text-muted); }
        .setting-item input {
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: var(--text-color);
            font-size: 0.9rem;
        }
        .setting-item input:focus { outline: none; border-color: var(--primary-color); }

        /* Message Log */
        .message-log {
            max-height: 150px; overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px; padding: 10px;
            font-family: 'Courier New', monospace; font-size: 0.8rem;
        }
        .log-entry { padding: 3px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.05); }
        .log-time { color: var(--text-muted); margin-right: 6px; }
        .log-sent { color: #64B5F6; }
        .log-received { color: #81C784; }
        .log-emergency { color: #ff5252; font-weight: bold; }

        /* Stats */
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .stat-item { text-align: center; }
        .stat-value { font-size: 1rem; font-weight: 600; font-family: monospace; }
        .stat-label { font-size: 0.7rem; color: var(--text-muted); }

        /* Instructions */
        .instructions {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            font-size: 0.85rem;
        }
        .instructions-title {
            font-weight: 600;
            margin-bottom: 6px;
            color: var(--primary-color);
        }
        .instructions ul {
            margin-left: 20px;
            line-height: 1.6;
        }

        @media (max-width: 480px) {
            .control-btn { width: 60px; height: 60px; font-size: 1.5rem; }
            .key-display { width: 50px; height: 50px; }
            .key-display .key-char { font-size: 1.1rem; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            .settings-grid, .metrics-display { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <header>
        <h1>ü§ñ Robot Teleoperation</h1>
        <p class="subtitle">WebRTC DataChannel Control Interface</p>
    </header>

    <div class="container">
        <!-- Connection Status -->
        <div class="card">
            <div class="status-bar">
                <div class="status-indicator">
                    <span id="status-dot" class="status-dot"></span>
                    <span id="status-text">Disconnected</span>
                </div>
                <button id="connect-btn" class="connect-btn">Connect</button>
            </div>
        </div>

        <!-- Instructions -->
        <div class="instructions">
            <div class="instructions-title">üéÆ How to Control</div>
            <ul>
                <li><strong>Hold</strong> arrow keys or WASD to move</li>
                <li><strong>Release</strong> keys to stop automatically</li>
                <li>Press <strong>Space</strong> for emergency stop</li>
            </ul>
        </div>

        <!-- Emergency Stop -->
        <button id="emergency-stop-btn" class="emergency-btn" disabled>
            <span>üõë</span>
            <span>EMERGENCY STOP (Space)</span>
        </button>

        <!-- Control Panel -->
        <div class="card">
            <div class="card-title"><span>üéÆ</span> Keyboard Control</div>
            
            <!-- Visual Keyboard Display -->
            <div class="keyboard-display">
                <div class="key-row">
                    <div id="key-w" class="key-display">
                        <span class="key-char">W</span>
                        <span class="key-label">FWD</span>
                    </div>
                </div>
                <div class="key-row">
                    <div id="key-a" class="key-display">
                        <span class="key-char">A</span>
                        <span class="key-label">LEFT</span>
                    </div>
                    <div id="key-s" class="key-display">
                        <span class="key-char">S</span>
                        <span class="key-label">BACK</span>
                    </div>
                    <div id="key-d" class="key-display">
                        <span class="key-char">D</span>
                        <span class="key-label">RIGHT</span>
                    </div>
                </div>
            </div>

            <!-- Current Command Display -->
            <div class="command-display">
                <div class="command-label">Current Command</div>
                <div id="command-value" class="command-value stopped">STOPPED</div>
            </div>

            <!-- Touch/Mouse Buttons -->
            <div class="controls-wrapper">
                <div class="control-row">
                    <button id="btn-forward" class="control-btn btn-forward" disabled></button>
                </div>
                <div class="control-row">
                    <button id="btn-left" class="control-btn btn-left" disabled></button>
                    <div style="width: 70px;"></div>
                    <button id="btn-right" class="control-btn btn-right" disabled></button>
                </div>
                <div class="control-row">
                    <button id="btn-backward" class="control-btn btn-backward" disabled></button>
                </div>
            </div>

            <!-- Metrics -->
            <div class="metrics-display">
                <div class="metric-item">
                    <div class="metric-label">Linear Y</div>
                    <div id="linear-y" class="metric-value">0.00</div>
                    <div class="metric-unit">m/s</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Angular Z</div>
                    <div id="angular-z" class="metric-value">0.00</div>
                    <div class="metric-unit">rad/s</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Latency</div>
                    <div id="latency" class="metric-value latency-good">--</div>
                    <div class="metric-unit">ms</div>
                </div>
            </div>
        </div>

        <!-- Settings -->
        <div class="card">
            <div class="card-title"><span>‚öôÔ∏è</span> Settings</div>
            <div class="settings-grid">
                <div class="setting-item">
                    <label for="relay-url">Relay Server URL</label>
                    <input type="text" id="relay-url" value="">
                </div>
                <div class="setting-item">
                    <label for="connection-mode">Connection Mode</label>
                    <select id="connection-mode" style="padding: 8px; background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: var(--text-color); font-size: 0.9rem;">
                        <option value="webrtc">WebRTC DataChannel</option>
                        <option value="websocket">WebSocket</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label for="linear-speed">Linear Speed (m/s)</label>
                    <input type="number" id="linear-speed" value="1.0" min="0.1" max="5" step="0.1">
                </div>
                <div class="setting-item">
                    <label for="angular-speed">Angular Speed (rad/s)</label>
                    <input type="number" id="angular-speed" value="1.0" min="0.1" max="3" step="0.1">
                </div>
                <div class="setting-item">
                    <label for="send-rate">Send Rate (Hz)</label>
                    <input type="number" id="send-rate" value="20" min="1" max="60" step="1">
                </div>
            </div>
        </div>

        <!-- Statistics -->
        <div class="card">
            <div class="card-title"><span>üìä</span> Statistics</div>
            <div class="stats-grid">
                <div class="stat-item"><div id="stat-sent" class="stat-value">0</div><div class="stat-label">Sent</div></div>
                <div class="stat-item"><div id="stat-received" class="stat-value">0</div><div class="stat-label">Received</div></div>
                <div class="stat-item"><div id="stat-bytes-sent" class="stat-value">0</div><div class="stat-label">Bytes Out</div></div>
                <div class="stat-item"><div id="stat-bytes-recv" class="stat-value">0</div><div class="stat-label">Bytes In</div></div>
            </div>
        </div>

        <!-- Message Log -->
        <div class="card">
            <div class="card-title"><span>üìù</span> Message Log</div>
            <div id="message-log" class="message-log">
                <div class="log-entry"><span class="log-time">[--:--:--]</span><span>Ready to connect...</span></div>
            </div>
        </div>
    </div>

    <script src="twist.js"></script>
    <script src="webrtc.js"></script>
    <script src="ws-client.js"></script>
    <script src="controls.js"></script>
    
    <script>
        // DOM Elements
        const elements = {
            statusDot: document.getElementById('status-dot'),
            statusText: document.getElementById('status-text'),
            connectBtn: document.getElementById('connect-btn'),
            emergencyStopBtn: document.getElementById('emergency-stop-btn'),
            btnForward: document.getElementById('btn-forward'),
            btnBackward: document.getElementById('btn-backward'),
            btnLeft: document.getElementById('btn-left'),
            btnRight: document.getElementById('btn-right'),
            linearY: document.getElementById('linear-y'),
            angularZ: document.getElementById('angular-z'),
            latency: document.getElementById('latency'),
            commandValue: document.getElementById('command-value'),
            relayUrl: document.getElementById('relay-url'),
            connectionMode: document.getElementById('connection-mode'),
            linearSpeed: document.getElementById('linear-speed'),
            angularSpeed: document.getElementById('angular-speed'),
            sendRate: document.getElementById('send-rate'),
            messageLog: document.getElementById('message-log'),
            statSent: document.getElementById('stat-sent'),
            statReceived: document.getElementById('stat-received'),
            statBytesSent: document.getElementById('stat-bytes-sent'),
            statBytesRecv: document.getElementById('stat-bytes-recv'),
            // Key displays
            keyW: document.getElementById('key-w'),
            keyA: document.getElementById('key-a'),
            keyS: document.getElementById('key-s'),
            keyD: document.getElementById('key-d')
        };

        // Connection clients (WebRTC or WebSocket)
        let webrtcClient = null;
        let wsClient = null;
        let currentClient = null;  // Points to active client
        
        let latencyHistory = [];
        const MAX_LATENCY_SAMPLES = 20;

        // Initialize controls
        const controls = new RobotControls({
            linearSpeed: parseFloat(elements.linearSpeed.value),
            angularSpeed: parseFloat(elements.angularSpeed.value),
            sendRate: parseInt(elements.sendRate.value),
            onCommand: handleCommand
        });

        // Initialize button bindings
        controls.init({ 
            forward: 'btn-forward', 
            backward: 'btn-backward', 
            left: 'btn-left', 
            right: 'btn-right' 
        });

        // Set up key display elements for visual feedback
        controls.setKeyDisplays({
            forward: 'key-w',
            backward: 'key-s',
            left: 'key-a',
            right: 'key-d'
        });

        /**
         * Get the currently active client
         */
        function getActiveClient() {
            return currentClient;
        }

        /**
         * Check if connected
         */
        function isConnected() {
            return currentClient && currentClient.isConnected;
        }

        /**
         * Handle velocity command from controls
         */
        function handleCommand(velocity) {
            updateVelocityDisplay(velocity);
            updateCommandDisplay(velocity);
            
            if (isConnected()) {
                const twist = new TwistMessage({ 
                    linearY: velocity.linearY, 
                    angularZ: velocity.angularZ, 
                    timestamp: Date.now() 
                });
                if (currentClient.send(twist.encode())) {
                    if (velocity.linearY !== 0 || velocity.angularZ !== 0) {
                        logMessage('sent', `lin.y=${velocity.linearY.toFixed(2)}, ang.z=${velocity.angularZ.toFixed(2)}`);
                    }
                    updateStats();
                }
            }
        }

        /**
         * Update the current command display
         */
        function updateCommandDisplay(velocity) {
            const cmdElem = elements.commandValue;
            
            if (velocity.linearY === 0 && velocity.angularZ === 0) {
                cmdElem.textContent = 'STOPPED';
                cmdElem.className = 'command-value stopped';
            } else {
                let parts = [];
                if (velocity.linearY > 0) parts.push('FORWARD');
                if (velocity.linearY < 0) parts.push('BACKWARD');
                if (velocity.angularZ > 0) parts.push('LEFT');
                if (velocity.angularZ < 0) parts.push('RIGHT');
                
                cmdElem.textContent = parts.join(' + ');
                cmdElem.className = 'command-value';
            }
        }

        /**
         * Emergency stop
         */
        function emergencyStop() {
            controls.stop();
            
            if (isConnected()) {
                const stopTwist = TwistMessage.zero();
                for (let i = 0; i < 3; i++) currentClient.send(stopTwist.encode());
                logMessage('emergency', 'üõë EMERGENCY STOP');
                updateStats();
            }
            
            updateVelocityDisplay({ linearY: 0, angularZ: 0 });
            updateCommandDisplay({ linearY: 0, angularZ: 0 });
        }

        /**
         * Update velocity display
         */
        function updateVelocityDisplay(velocity) {
            elements.linearY.textContent = velocity.linearY.toFixed(2);
            elements.angularZ.textContent = velocity.angularZ.toFixed(2);
            elements.linearY.className = 'metric-value' + (velocity.linearY > 0 ? ' positive' : velocity.linearY < 0 ? ' negative' : '');
            elements.angularZ.className = 'metric-value' + (velocity.angularZ > 0 ? ' positive' : velocity.angularZ < 0 ? ' negative' : '');
        }

        /**
         * Update latency display
         */
        function updateLatencyDisplay(latencyMs) {
            latencyHistory.push(latencyMs);
            if (latencyHistory.length > MAX_LATENCY_SAMPLES) latencyHistory.shift();
            const avgLatency = latencyHistory.reduce((a, b) => a + b, 0) / latencyHistory.length;
            elements.latency.textContent = Math.round(avgLatency);
            elements.latency.className = 'metric-value ' + (avgLatency < 50 ? 'latency-good' : avgLatency < 150 ? 'latency-medium' : 'latency-bad');
        }

        /**
         * Handle incoming message (from either WebRTC or WebSocket)
         */
        function handleIncomingMessage(data) {
            try {
                const twist = TwistMessage.decode(data);
                if (twist.timestamp > 0) updateLatencyDisplay(Date.now() - twist.timestamp);
            } catch (e) {}
            updateStats();
        }

        /**
         * Connect to relay
         */
        async function connect() {
            const relayUrl = elements.relayUrl.value.trim();
            const mode = elements.connectionMode.value;
            
            if (!relayUrl) { logMessage('error', 'Enter relay URL'); return; }
            
            elements.connectBtn.disabled = true;
            elements.connectBtn.textContent = 'Connecting...';
            updateStatus('connecting');
            
            let success = false;
            
            if (mode === 'websocket') {
                // WebSocket mode
                wsClient = new WSDataClient(relayUrl);
                wsClient.onStateChange = (state) => { 
                    updateStatus(state); 
                    logMessage('info', `WS State: ${state}`); 
                };
                wsClient.onMessage = handleIncomingMessage;
                wsClient.onError = (e) => logMessage('error', e.message);
                wsClient.onOpen = () => { 
                    currentClient = wsClient;
                    enableControls(true); 
                    elements.connectBtn.textContent = 'Disconnect'; 
                    elements.connectBtn.disabled = false;
                    logMessage('info', '‚úì WebSocket connected! Use arrow keys/WASD.');
                };
                wsClient.onClose = () => { 
                    enableControls(false); 
                    elements.connectBtn.textContent = 'Connect'; 
                    elements.connectBtn.disabled = false; 
                };
                
                success = await wsClient.connect();
                
            } else {
                // WebRTC mode
                webrtcClient = new WebRTCClient(relayUrl);
                webrtcClient.onStateChange = (state) => { 
                    updateStatus(state); 
                    logMessage('info', `WebRTC State: ${state}`); 
                };
                webrtcClient.onMessage = handleIncomingMessage;
                webrtcClient.onError = (e) => logMessage('error', e.message);
                webrtcClient.onOpen = () => { 
                    currentClient = webrtcClient;
                    enableControls(true); 
                    elements.connectBtn.textContent = 'Disconnect'; 
                    elements.connectBtn.disabled = false;
                    logMessage('info', '‚úì WebRTC connected! Use arrow keys/WASD.');
                };
                webrtcClient.onClose = () => { 
                    enableControls(false); 
                    elements.connectBtn.textContent = 'Connect'; 
                    elements.connectBtn.disabled = false; 
                };
                
                success = await webrtcClient.connect();
            }
            
            if (!success) {
                elements.connectBtn.textContent = 'Connect';
                elements.connectBtn.disabled = false;
                updateStatus('failed');
                
                // Suggest WebSocket if WebRTC failed
                if (mode === 'webrtc') {
                    logMessage('error', 'WebRTC failed. Try switching to WebSocket mode in Settings.');
                }
            }
        }

        /**
         * Disconnect
         */
        function disconnect() {
            if (wsClient) { 
                wsClient.close(); 
                wsClient = null; 
            }
            if (webrtcClient) { 
                webrtcClient.close(); 
                webrtcClient = null; 
            }
            currentClient = null;
            controls.stop();
            enableControls(false);
            updateStatus('disconnected');
            elements.connectBtn.textContent = 'Connect';
            latencyHistory = [];
            elements.latency.textContent = '--';
        }

        /**
         * Update status display
         */
        function updateStatus(state) {
            elements.statusDot.className = 'status-dot' + (state === 'connected' ? ' connected' : state === 'connecting' ? ' connecting' : '');
            elements.statusText.textContent = state === 'connected' ? 'Connected' : state === 'connecting' ? 'Connecting...' : state === 'failed' ? 'Failed' : 'Disconnected';
        }

        /**
         * Enable/disable controls
         */
        function enableControls(enabled) {
            ['btnForward', 'btnBackward', 'btnLeft', 'btnRight', 'emergencyStopBtn'].forEach(b => elements[b].disabled = !enabled);
        }

        /**
         * Log message
         */
        function logMessage(type, message) {
            const time = new Date().toTimeString().split(' ')[0];
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${time}]</span><span class="log-${type}">${message}</span>`;
            elements.messageLog.appendChild(entry);
            elements.messageLog.scrollTop = elements.messageLog.scrollHeight;
            while (elements.messageLog.children.length > 50) elements.messageLog.removeChild(elements.messageLog.firstChild);
        }

        /**
         * Update stats
         */
        function updateStats() {
            if (currentClient) {
                const s = currentClient.stats;
                elements.statSent.textContent = s.messagesSent;
                elements.statReceived.textContent = s.messagesReceived;
                elements.statBytesSent.textContent = s.bytesSent < 1024 ? s.bytesSent : (s.bytesSent/1024).toFixed(1)+'K';
                elements.statBytesRecv.textContent = s.bytesReceived < 1024 ? s.bytesReceived : (s.bytesReceived/1024).toFixed(1)+'K';
            }
        }

        // Event Listeners
        elements.connectBtn.addEventListener('click', () => isConnected() ? disconnect() : connect());
        elements.emergencyStopBtn.addEventListener('click', emergencyStop);
        
        // Spacebar for emergency stop
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.repeat && e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT') { 
                e.preventDefault(); 
                emergencyStop(); 
            }
        });
        
        // Settings changes
        elements.linearSpeed.addEventListener('change', () => controls.linearSpeed = parseFloat(elements.linearSpeed.value));
        elements.angularSpeed.addEventListener('change', () => controls.angularSpeed = parseFloat(elements.angularSpeed.value));
        elements.sendRate.addEventListener('change', () => controls.setSendRate(parseInt(elements.sendRate.value)));
        
        // Connection mode change - disconnect if connected
        elements.connectionMode.addEventListener('change', () => {
            if (isConnected()) {
                disconnect();
                logMessage('info', 'Disconnected due to mode change');
            }
        });
        
        // Prevent context menu on control buttons
        document.querySelectorAll('.control-btn, .emergency-btn').forEach(btn => btn.addEventListener('contextmenu', e => e.preventDefault()));

        // Auto-detect relay URL from current page location
        function getDefaultRelayUrl() {
            const protocol = window.location.protocol;
            const host = window.location.host;
            return `${protocol}//${host}`;
        }
        
        // Set default relay URL
        elements.relayUrl.value = getDefaultRelayUrl();

        logMessage('info', `Ready. Server: ${getDefaultRelayUrl()}`);
        console.log('[App] Robot Teleoperation initialized');
    </script>
</body>
</html>
